@declare{'genMethodCall'}
@if{static}J@{ifaceSimpleName}@else{}j_@{ifaceName}@end{}.@{method.name}(
	@foreach{param: method.params}
@includeNamed{'convParam'}
	@end{", "})
@end{}

@declare{'convParam'}
	@if{param.type.startsWith('io.vertx.core.Handler<')}
		@code{genericType = helper.getGenericType(param.type)}
		@if{genericType.startsWith('io.vertx.core.AsyncResult<')}
			@code{genericType = helper.getGenericType(genericType)}
			@if{genericType.equals('java.lang.Void')}
function(ar) { if (ar.succeeded()) { @{param.name}(null, null) } else { @{param.name}(null, ar.cause()); }}
			@else{helper.isBasicType(genericType)}
function(ar) { if (ar.succeeded()) { @{param.name}(@includeNamed{'convReturn'; templ='arVal'; returnType=genericType}, null) } else { @{param.name}(null, ar.cause()); }}
			@else{}
function(ar) { if (ar.succeeded()) { @{param.name}(new @{helper.getSimpleName(genericType)}(ar.result()), null) } else { @{param.name}(null, ar.cause()); }}
			@end{}
		@else{genericType.equals('java.lang.Void')}
@{param.name}
		@else{helper.isBasicType(genericType)}
function(jVal) { @{param.name}(@includeNamed{'convReturn'; templ='basicVal'; returnType=genericType})}
		@else{}
function(jVal) { @{param.name}(new @{helper.getSimpleName(genericType)}(jVal))}
		@end{}
	@else{param.type.equals('io.vertx.core.json.JsonObject')}
new io.vertx.core.json.JsonObject(JSON.stringify(@{param.name}))
  @else{param.type.equals('io.vertx.core.net.NetServerOptions')}
new io.vertx.core.net.NetServerOptions(new io.vertx.core.json.JsonObject(JSON.stringify(@{param.name})))
	@else{helper.isBasicType(param.type)}
@{param.name}
	@else{}
@{param.name}._jdel()
	@end{}
@end{}

@declare{'basicVal'}
jVal
@end{}

@declare{'arVal'}
ar.result()
@end{}

@declare{'convReturn'}
	@if{returnType.equals('java.lang.String')}
@includeNamed{templ}
	@else{helper.isBasicType(returnType)}
@includeNamed{templ}
  @else{}
new @{helper.getSimpleName(returnType)}(@includeNamed{templ})
	@end{}
@end{}

@declare{'genMethod'}
	@if{static == method.staticMethod}
		@if{method.comment != null}
  /*\n
  @{method.comment}
  */\n
		@end{}
  @if{static}@{ifaceSimpleName}@else{}this@end{}.@{method.name} = function(@foreach{param0: method.params}@{param0.name}@end{", "}) {\n
		@if{method.squashed}
    switch (arguments.length) {\n
			@foreach{method: methodsByName.get(method.name)}
      case @{method.params.size()}:\n
				@if{!method.returnType.equals("void")}
					@if{method.fluent}
        @includeNamed{'genMethodCall'};\n
						@if{static}
        return @{ifaceSimpleName};\n
						@else{}
        return that;\n
						@end{}
					@else{}
        return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=method.returnType};\n
					@end{}
				@else{}
        @includeNamed{'genMethodCall'};\n
        return;\n
				@end{}
			@end{}
      default: throw "Invalid arguments"\n
    }\n
		@else{}
			@if{!method.returnType.equals("void")}
				@if{method.fluent}
    @includeNamed{'genMethodCall'};\n
    			@if{static}
    return @{ifaceSimpleName};\n
    			@else{}
    return that;\n
    			@end{}
				@else{}
    return @includeNamed{'convReturn'; templ='genMethodCall'; returnType=method.returnType};\n
				@end{}
			@else{}
	  @includeNamed{'genMethodCall'};\n
			@end{}
		@end{}
  };\n\n
	@end{}
@end{}

// Here is our generated JavaScript module\n\n

// Require stuff that we need\n
@foreach{referencedType : referencedTypes}
var @{helper.getSimpleName(referencedType)} = require('vertx/@{helper.convertCamelCaseToFileNameWithUnderscores(helper.getSimpleName(referencedType))}');\n
@end{}
\n
var io = Packages.io;\n
var J@{ifaceSimpleName} = Packages.@{helper.getNonGenericType(ifaceFQCN)};
\n\n
@code{ifaceName = helper.decapitaliseFirstLetter(ifaceSimpleName)}
@if{ifaceComment != null}
/*\n
@{ifaceComment}
*/\n
@end{}
var @{ifaceSimpleName} = function(j_val) {\n
  var j_@{ifaceName} = j_val;\n
  var that = this;
@foreach{superType: superTypes}
  @{helper.getSimpleName(helper.getNonGenericType(superType))}.call(this, j_val);\n
@end{}
\n
@foreach{method:squashedMethods}
@includeNamed{'genMethod';static=false}
@end{}
  // Get a reference to the underlying Java delegate\n
  this._jdel = function() {\n
    return j_@{ifaceName};\n
  }\n\n
};\n
\n
@foreach{method:squashedMethods}
@includeNamed{'genMethod';static=true}
@end{}

// We export the Constructor function\n
module.exports = @{ifaceSimpleName};





